/*******************************************************************************
 * Copyright 2013-2016 alladin-IT GmbH
 * Copyright 2013-2016 Rundfunk und Telekom Regulierungs-GmbH (RTR-GmbH)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/
package at.rtr.rmbt.statisticServer;

import at.rtr.rmbt.shared.Classification;
import at.rtr.rmbt.shared.model.SpeedItems;
import at.rtr.rmbt.shared.model.SpeedItems.SpeedItem;
import at.rtr.rmbt.shared.smoothing.Smoothable;
import at.rtr.rmbt.shared.smoothing.SmoothingFunction;
import at.rtr.rmbt.statisticServer.opendata.dto.*;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.PropertyNamingStrategy;
import com.google.gson.Gson;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiImplicitParam;
import io.swagger.annotations.ApiImplicitParams;
import io.swagger.annotations.ApiOperation;
import org.apache.commons.dbutils.BasicRowProcessor;
import org.apache.commons.dbutils.GenerousBeanProcessor;
import org.apache.commons.dbutils.handlers.BeanHandler;
import org.apache.commons.dbutils.handlers.BeanListHandler;
import org.restlet.data.Form;
import org.restlet.data.Status;
import org.restlet.resource.Get;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;


@Api(value="/opentests/", description = "Open test search")
public class OpenTestResource extends ServerResource
{
    //maximum of rows sent in one single request
    public final int MAXROWS = 400;

    /**
     * disable/enable smoothing of returned curves
     */
    public final static boolean RETURN_SMOOTHED_SPEED_CURVES = false;

    /**
     * data amount for centered moving average must not be < 3 and odd.
     * The function needs x values on the "left" and "right side" of the current value, where x = (SMOOTHING_DATA_AMOUNT-1)/2
     * f(i) = 1/x * (e[i-x] + e[i-x+1] + ... + e[i] + ... + e[i+x-1] + e[i+x])
     */
    public final static int SMOOTHING_DATA_AMOUNT = 5;

    @Path("/opentests/{open-test-uuid}")
    @ApiOperation(value = "query for OpenTests",
            response = OpenTestDetailsDTO.class,
            httpMethod = "GET",
            nickname = "opentest-query")
    @GET
    @Get
    @ApiImplicitParams({
            @ApiImplicitParam(name = "open-test-uuid", value = "Mandatory. The open-test-uuid of the test.", dataType = "string", example = "Oc1326b7c-4141-42cb-b8c5-922c356a6cee", paramType = "path", required = true),
            @ApiImplicitParam(name = "verbose", value = "Optional. If >0 the threadwise speed curve is additionally returned.", dataType = "integer", example = "0", paramType = "query"),
            @ApiImplicitParam(name = "sender", value = "Optional. ID of the sender, for authentification.", dataType = "string", paramType = "query")
    })
    public String request(final String entity) {
        int verboseLevel = 0;
        addAllowOrigin();

        //routing should be in a way in which open_test_uuid is always set
        String openUUID = getRequest().getAttributes().get("open_test_uuid").toString();


        final Form getParameters = getRequest().getResourceRef().getQueryAsForm();
        //allow sender + verbose
        for (String name : getParameters.getNames()) {
            if (name.equals("verbose")) {
                try {
                    verboseLevel = Integer.parseInt(getParameters.getFirstValue("verbose"));
                } catch (NumberFormatException ex) {
                    Logger.getGlobal().info("invalid non-numberic verbosity level");
                }
            } else if (name.equals("sender") || name.equals("?sender")) { //allow for ?sender; used by some users due to error in old documentation
                //ignore for now
                final String sender_id;
                if (name.equals("sender"))
                    sender_id = "sender " + getParameters.getFirstValue("sender");
                else
                    sender_id = "sender " + getParameters.getFirstValue("?sender");
//        		System.out.println(sender_id);
                //the logging block would require write access to the database
        		/*
        		final String sql = "UPDATE json_sender SET count = count + 1 WHERE sender_id = ?";
        		PreparedStatement ps = null;
                try
                {
                    ps = conn.prepareStatement(sql);
                    ps.setString(1, sender_id);
                    
                    ps.executeUpdate();
                } catch  (final SQLException e)
                {
                    Logger.getLogger(OpenTestResource.class.getName()).log(Level.SEVERE, null, e);
                }
                */
            }
        }

        OpenTestDetailsDTO ret = getSingleOpenTest(openUUID, verboseLevel);
        ObjectMapper om = new ObjectMapper();
        om.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
        String sr = null;
        try {
            sr = om.writer().writeValueAsString(ret);
        } catch (JsonProcessingException e) {
            e.printStackTrace();
            setStatus(Status.SERVER_ERROR_INTERNAL);
        }

        return sr;
    }

    /**
     * Gets the JSON-Representation of all open-data-fields for one specific
     * open-test-uuid
     * @param openTestUUID
     * @return the json-string
     *
     *
     * columns in csv ("open data")
     * 1:open_uuid,
     * 2:open_test_uuid,
     * 3:time,
     * 4:cat_technology,
     * 5:network_type,
     * 6:lat,
     * 7:long,
     * 8:loc_src,
     * 9:gkz,
     * 10:download_kbit,
     * 11:upload_kbit,
     * 12:ping_ms,
     * 13:signal_strength,
     * 14:server_name,
     * 15:test_duration,
     * 16:num_threads,
     * 17:platform,
     * 18:model,
     * 19:client_version,
     * 20:network_mcc_mnc,
     * 21:network_name,
     * 22:sim_mcc_mnc,
     * 23:connection,
     * 24:asn,
     * 25:ip_anonym,
     * 26:ndt_download_kbit,
     * 27:ndt_upload_kbit,
     * 28:implausible,
     * 29:lte_rsrp
     *
     *
     * Columns in test table
     *   uid (internal)
     *   uuid (private)
     *   client_id
     *   client_version
     *   client_name
     *   client_language (private)
     *   token (private, obsolete)
     *   server_id
     *   port
     *   use_ssl *
     *   time
     *   speed_upload
     *   speed_download
     *   ping_shortest
     *   encryption *
     *   client_public_ip (private)
     *   platform
     *   os_version (internal)
     *   api_level (internal)
     *   device
     *   model
     *   product
     *   phone_type (internal)
     *   data_state (internal)
     *   network_country (internal)
     *   network_operator
     *   network_operator_name
     *   network_sim_country (internal)
     *   network_sim_operator
     *   network_sim_operator_name
     *   wifi_ssid (private)
     *   wifi_bssid (private)
     *   wifi_network_id (private)
     *   duration
     *   num_threads
     *   status
     *   timezone (private)
     *   bytes_download
     *   bytes_upload
     *   nsec_download
     *   nsec_upload
     *   server_ip
     *   client_software_version
     *   geo_lat
     *   geo_long
     *   network_type
     *   location
     *   signal_strength
     *   software_revision
     *   client_test_counter
     *   nat_type
     *   client_previous_test_status
     *   public_ip_asn
     *   speed_upload_log
     *   speed_download_log
     *   total_bytes_download
     *   total_bytes_upload
     *   wifi_link_speed
     *   public_ip_rdns
     *   public_ip_as_name
     *   test_slot
     *   provider_id
     *   network_is_roaming (internal)
     *   ping_shortest_log
     *   run_ndt (internal)
     *   num_threads_requested
     *   client_public_ip_anonymized
     *   gkz (obsolete)
     *   zip (obsolete)
     *   kg_nr_bev
     *   gkz_bev
     *   gkz_sa
     *   land_cover
     *   geo_provider
     *   geo_accuracy
     *   deleted (internal)
     *   comment (internal)
     *   open_uuid
     *   client_time (internal)
     *   zip_code_geo (obsolete)
     *   mobile_provider_id
     *   roaming_type
     *   open_test_uuid
     *   country_asn
     *   country_location
     *   test_if_bytes_download
     *   test_if_bytes_upload
     *   implausible
     *   testdl_if_bytes_download
     *   testdl_if_bytes_upload
     *   testul_if_bytes_download
     *   testul_if_bytes_upload
     *   country_geoip
     *   location_max_distance
     *   location_max_distance_gps
     *   network_group_name
     *   network_group_type
     *   time_dl_ns
     *   time_ul_ns
     *   num_threads_ul
     *   lte_rsrp
     *   lte_rsrq
     *   mobile_network_id
     *   mobile_sim_id
     *   dist_prev
     *   speed_prev
     *   tag
     *   ping_median
     *   ping_median_log
     *   client_ip_local_type (private)
     *
     *   private: visible to user only (not public)
     *   internal: not visible (neither user nor public)
     *
     */

    private OpenTestDetailsDTO getSingleOpenTest(String openTestUUID, int verboseLevel) {
        final String sql = "SELECT t.uid as test_uid, " +
                " ('P' || t.open_uuid) open_uuid," +  //csv 1:open_uuid, UUID prefixed with 'P'
                " ('O' || t.open_test_uuid) open_test_uuid," + //csv  open_test_uuid, UUID prefixed with 'O'
                " to_char(t.time AT TIME ZONE 'UTC', 'YYYY-MM-DD HH24:MI:SS') \"time\"," +
                " t.time full_time," + //csv: 3:time server time-stamp of start of measurement
                " t.client_time client_time," +  //(internal) client time-stamp of start of measure
                " t.network_group_name cat_technology," + //csv 4:cat_technology
                " t.network_group_type network_type," + //csv 5:network_type
                /*
                " t.geo_lat lat," + //csv 6:lat
                " t.geo_long long," + // csv 7:long
                " t.geo_provider loc_src," + //csv 8:loc_src android: 'gps'/'network'; browser/iOS: '' (empty string)
                " t.geo_accuracy loc_accuracy, " + //accuracy of geo location in m
                */
                //csv 6:lat
                " (CASE WHEN (t.geo_accuracy < ?) AND (t.geo_provider IS DISTINCT FROM 'manual') AND (t.geo_provider IS DISTINCT FROM 'geocoder') THEN" +
                " t.geo_lat" +
                " WHEN (t.geo_accuracy < ?) THEN" +
                " ROUND(t.geo_lat*1111)/1111" + // approx 100m
                " ELSE null" +
                " END) latitude," +
                // csv 7:long
                " (CASE WHEN (t.geo_accuracy < ?) AND (t.geo_provider IS DISTINCT FROM 'manual') AND (t.geo_provider IS DISTINCT FROM 'geocoder') THEN" +
                " t.geo_long" +
                " WHEN (t.geo_accuracy < ?) THEN" +
                " ROUND(t.geo_long*741)/741 " + //approx 100m
                " ELSE null" +
                " END) longitude," +
                // csv 8:loc_src android: 'gps'/'network'; browser/iOS: '' (empty string)
                " (CASE WHEN ((t.geo_provider = 'manual') OR (t.geo_provider = 'geocoder')) THEN" +
                " 'rastered'" + //make raster transparent
                " ELSE t.geo_provider" +
                " END) loc_src," +
                // accuracy of geo location in m
                " (CASE WHEN (t.geo_accuracy < ?) AND (t.geo_provider IS DISTINCT FROM 'manual') AND (t.geo_provider IS DISTINCT FROM 'geocoder') " +
                " THEN t.geo_accuracy " +
                " WHEN (t.geo_accuracy < 100) AND ((t.geo_provider = 'manual') OR (t.geo_provider = 'geocoder')) THEN 100" + // limit accuracy to 100m
                " WHEN (t.geo_accuracy < ?) THEN t.geo_accuracy" +
                " ELSE null END) loc_accuracy, " +
                " NULL zip_code," +
                " t.kg_nr_bev kg_nr," +
                " t.gkz_bev gkz," +
                " t.gkz_sa gkz_sa," +
                " t.land_cover land_cover," +
                " k.kg locality," +
                " k.pg community," +
                " k.pb district," +
                " k.bl province," +
                " NULL cov800cat," +
                " t.speed_download download_kbit," + //csv 10:download_kbit
                " t.speed_upload upload_kbit," + //csv 11: upload_kbit
                " t.wifi_link_speed," + // nominal speed of wifi-link in mbit/s , Android-only
                " (t.ping_median::float / 1000000) ping_ms," + //median ping-time in ms (stored in ns in data base)
                " signal_strength," + //csv 13:signal_strength RSSI, mainly GSM/UMTS and Wifi, Android only, in dBm
                " lte_rsrp," + // csv 29: signal_strength RSRP, Android only, in dBm
                " lte_rsrq," + // signal quality RSRQ, Android only, in dB
                " ts.name server_name," + //csv 14:server_name, name of the test server used for download/upload (not applicable for JStest)
                " implausible, " +  //csv 28:implausible, measurement not shown in map nor used in statistics, normally not visible
                " pinned, " + //true, if test is used in statistics, false if it is a repeated measurement
                " public_ip_as_name, " + //name of AS (not number)
                " duration test_duration," +  //csv 15:test_duration, nominal duration of downlink and uplink throughput tests in seconds
                " num_threads_requested," + // number of threads requested by control-server
                " num_threads," + //csv 16:num_threads, number of threads used in downlink throughput test (uplink may differ)
                " num_threads_ul," + // number of threads used in uplink test
                " COALESCE(t.plattform, t.client_name) as platform," + //csv 17:platform; currently used: 'CLI'/'Android'/Applet/iOS/[from client_name: RMBTws, RMBTjs](null); (null) is used for RMBTjs 
                " COALESCE(adm.fullname, t.model) model," + //csv 18:model, translated t.model (model_native) to human readable form
                " t.model model_native," + //device used for test; Android API 'model'; iOS:'product'; Browser: Browser-name (zB Firefox)
                " t.product product," +  // product used for test; Android APO 'product'; iOS: '' (not used); Browser: same as for model (browser name)
                " t.client_software_version client_version," + //csv 19:client_version, SW-version of client software (not RMBT-client-version), eg. '1.3'
                " t.network_operator network_mcc_mnc," + //csv 20:network_mcc_mnc, mobile country and network code of current network (Android only), string, eg "232-12'
                " network_country," + //(internal) Android-only, country code derived by client from mobile network code
                // " network_is_roaming," + //(internal) roaming-status of mobile network, boolean or (null); Android-only (obsolete)
                " roaming_type," + //roaming-status of mobile network, integer: 0:not roaming,1:national,2:international,(null):unknown (eg. iOS)
                " t.network_operator_name network_name," + //csv 21:network_name, name of current mobile network as displayed on device (eg: '3likeHome')
                " t.network_sim_operator sim_mcc_mnc," + //csv 22:sim_mcc_mnc, home network of SIM (initial 5 digits from IMSI), eg '232-01'
                " t.network_sim_country sim_country," + //(internal) Android-only, country derived by client from SIM (country of home network)
                " COALESCE(mprov.name,msim.shortname,msim.name,prov.name) provider_name," +  //pre-defined list of providers (based on provider_id) //TODO replace provider
                " t.nat_type \"connection\"," + //csv 23:connection, translation-mechanism in NAT, eg. nat_local_to_public_ipv4
                " t.public_ip_asn asn," + //csv 24:asn, AS (autonomous system) number, number of public IP network
                " t.client_public_ip_anonymized ip_anonym," +  //csv 25:ip_anonym, anonymized IP of client (IPv4: 8 bits removed, IPv6: 72 bits removed)
                " (ndt.s2cspd*1000)::int ndt_download_kbit," + //csv 26:ndt_download_kbit, result of NDT downlink throughput test kbit/s
                " (ndt.c2sspd*1000)::int ndt_upload_kbit," + //csv 27 ndt_uoload_kbit, result of NDT uplink throughput test in kbit/s
                " country_geoip," + // country-code derived from public IP-address, eg. 'AT'
                " country_location," + // country-code derived from geo_location, eg. 'DE'
                " country_asn," + // country_code derived from AS, eg. 'EU'
                " bytes_download," + // number of bytes downloaded during test (download and upload) (obsolete)
                " bytes_upload," + // number of bytes uploaded during test (download and upload) (obsolete)
                " test_if_bytes_download," + //downloaded bytes on interface during total test (inc. training, ping, without NDT) (obsolete)
                " test_if_bytes_upload," + //uploaded bytes on interface during total test (inc. training, ping, without NDT) (obsolete)
                " testdl_if_bytes_download," + //downloaded bytes on interface during download-test (without training-seq)
                " testdl_if_bytes_upload," + //uploaded bytes on interface during download-test (without training-seq)
                " testul_if_bytes_download," + //downloaded bytes on interface during upload-test (without training-seq)
                " testul_if_bytes_upload," + //downloaded bytes on interface during upload-test (without training-seq)
                " (t.nsec_download::float / 1000000) duration_download_ms," + //duration of download-test in ms
                " (t.nsec_upload::float / 1000000) duration_upload_ms," + //duration of upload-test in ms
                " (t.time_dl_ns::float / 1000000) time_dl_ms," + //relative start time of download-test in ms (ignoring training-phase)
                " (t.time_ul_ns::float / 1000000) time_ul_ms," + //relative start time of download-test in ms (ignoring training-phase)
                // " phone_type" + //(internal) radio type of phone: 0 no mobile radio, 1 GSM (incl. UMTS,LTE) 2 CDMA (obsolete)
                " speed.items speed_items," + // json representation of individual up+down speed items
                " channel_number," +
                " radio_band," +
                " cell_location_id cell_area_code," +
                " cell_area_code cell_location_id" +
                " FROM test t" +
                " LEFT JOIN device_map adm ON adm.codename=t.model" +
                " LEFT JOIN test_server ts ON ts.uid=t.server_id" +
                " LEFT JOIN test_ndt ndt ON t.uid=ndt.test_id" +
                " LEFT JOIN provider prov ON t.provider_id=prov.uid" +
                " LEFT JOIN provider mprov ON t.mobile_provider_id=mprov.uid" +
                " LEFT JOIN mccmnc2name msim ON t.mobile_sim_id=msim.uid" +
                " LEFT JOIN oesterreich_bev_kg_lam_mitattribute_2017_10_02 k ON t.kg_nr_bev=k.kg_nr_int" +
                " LEFT JOIN speed ON speed.open_test_uuid=t.open_test_uuid" +
                " WHERE " +
                " t.deleted = false " +
                " AND t.status = 'FINISHED' " +
                " AND t.open_test_uuid = ? ";


        //System.out.println(sql);

        OpenTestDetailsDTO dto = new OpenTestDetailsDTO();

        final String[] columns;
        PreparedStatement ps = null;
        ResultSet rs = null;

        try
        {
            ps = conn.prepareStatement(sql);

            //insert filter for accuracy
            double accuracy = Double.parseDouble(settings.getString("RMBT_GEO_ACCURACY_DETAIL_LIMIT"));
            ps.setDouble(1, accuracy);
            ps.setDouble(2, accuracy);
            ps.setDouble(3, accuracy);
            ps.setDouble(4, accuracy);
            ps.setDouble(5, accuracy);
            ps.setDouble(6, accuracy);


            //openTestIDs are starting with "O"
            if (openTestUUID != null && openTestUUID.startsWith("O")) {
                openTestUUID = openTestUUID.substring(1);
            }
            ps.setObject(7, openTestUUID,Types.OTHER);

            if (!ps.execute())
                return null;
            rs = ps.getResultSet();

            BeanHandler<OpenTestDetailsDTO> handler = new BeanHandler<>(OpenTestDetailsDTO.class,new BasicRowProcessor(new GenerousBeanProcessor()));
            dto = handler.handle(rs);

            if (dto != null)
            {
                //classify download, upload, ping, signal
                dto.setDownloadClassification(Classification.classify(Classification.THRESHOLD_DOWNLOAD, dto.getDownloadKbit(), capabilities.getClassificationCapability().getCount()));
                dto.setUploadClassification(Classification.classify(Classification.THRESHOLD_UPLOAD, dto.getUploadKbit(), capabilities.getClassificationCapability().getCount()));
                dto.setPingClassification(Classification.classify(Classification.THRESHOLD_PING, Math.round(dto.getPingMs() * 1000000), capabilities.getClassificationCapability().getCount()));

                //classify signal accordingly
				if ((dto.getSignalStrength() != null || dto.getLteRsrp() != null)
						&& dto.getNetworkType() != null) { // signal available
					if (dto.getLteRsrp() == null) { // use RSSI
						if (dto.getNetworkType().equals("WLAN")) { // RSSI for Wifi
                            dto.setSignalClassification(Classification.classify(Classification.THRESHOLD_SIGNAL_WIFI, dto.getSignalStrength(), capabilities.getClassificationCapability().getCount()));
						} else { // RSSI for Mobile
                            dto.setSignalClassification(Classification.classify(Classification.THRESHOLD_SIGNAL_MOBILE, dto.getSignalStrength(), capabilities.getClassificationCapability().getCount()));
						}
					} else // RSRP for LTE
                        dto.setSignalClassification(Classification.classify(Classification.THRESHOLD_SIGNAL_RSRP,dto.getLteRsrp(), capabilities.getClassificationCapability().getCount()));
				} else { // no signal available
					dto.setSignalClassification(null);
				}


                //also load download/upload-speed-data, signal data and location data if possible

                // speed data
                final Gson gson = getGson(false);
                final SpeedItems speedItems = gson.fromJson(rs.getString("speed_items"), SpeedItems.class);

                //graphs
                OpenTestGraphDTO graphs = new OpenTestGraphDTO();

                if (speedItems != null)
                {
                    long lastTime = -1;
                    final List<SpeedItem> uploadList = speedItems.getAccumulatedSpeedItemsUpload();
                    //System.out.println(uploadList.size());
                    final List<SpeedItem> downloadList = speedItems.getAccumulatedSpeedItemsDownload();
                    //System.out.println(downloadList.size());
                    List<SpeedGraphItemDTO> downloadSpeeds = new ArrayList<>();
                    List<SpeedGraphItemDTO> uploadSpeeds = new ArrayList<>();

                    if (!RETURN_SMOOTHED_SPEED_CURVES) {
                        SpeedGraphItemDTO obj;
                        for (SpeedItem item : uploadList) {
                            obj = new SpeedGraphItemDTO();
                            final long time = Math.round((double) item.getTime() / 1e6);
                            if (time == lastTime)
                                continue;
                            obj.setTimeElapsed(item.getTime());
                            obj.setBytesTotal(item.getBytes());
                            uploadSpeeds.add(obj);
                            lastTime = time;
                        }
                        lastTime = -1;
                        for (SpeedItem item : downloadList) {
                            obj = new SpeedGraphItemDTO();
                            final long time = Math.round((double) item.getTime() / 1e6);
                            if (time == lastTime)
                                continue;
                            obj.setTimeElapsed(item.getTime());
                            obj.setBytesTotal(item.getBytes());
                            downloadSpeeds.add(obj);
                            lastTime = time;
                        }
                    }
                    else {
                        final List<? extends Smoothable> smoothedUploadList = SmoothingFunction.smooth(SmoothingFunction.CENTRAL_MOVING_AVARAGE, uploadList, SMOOTHING_DATA_AMOUNT);
                        final List<? extends Smoothable> smoothedDownloadList = SmoothingFunction.smooth(SmoothingFunction.CENTRAL_MOVING_AVARAGE, downloadList, SMOOTHING_DATA_AMOUNT);

                        lastTime = -1;

                        SpeedGraphItemDTO obj;
                        for (Smoothable item : smoothedUploadList) {
                            obj = new SpeedGraphItemDTO();
                            final long time = Math.round((double) item.getXValue() / 1000000);
                            if (time == lastTime)
                                continue;
                            obj.setTimeElapsed(time);
                            obj.setBytesTotal(item.getYValue());
                            uploadSpeeds.add(obj);
                        }

                        lastTime = -1;

                        for (Smoothable item : smoothedDownloadList) {
                            obj = new SpeedGraphItemDTO();
                            final long time = Math.round((double) item.getXValue() / 1e6);
                            if (time == lastTime)
                                continue;
                            obj.setTimeElapsed(time);
                            obj.setBytesTotal(item.getYValue());
                            downloadSpeeds.add(obj);
                        }
                    }

                    graphs.setDownload(downloadSpeeds);
                    graphs.setUpload(uploadSpeeds);
                }

                //if verbose - also add raw json data
                if (speedItems != null && verboseLevel > 0) {
                    Map<String, Map<Integer, List<SpeedItem>>> rawJSON = speedItems.getRawJSONData();

                    //threads
                    Map<String, Map<String, List<SpeedGraphItemDTO.SpeedItemThreadwise>>> threadwise = new HashMap<>();

                    //phases
                    for (String phase : rawJSON.keySet()) {

                        Map<String, List<SpeedGraphItemDTO.SpeedItemThreadwise>> threads = new HashMap<>();
                        threadwise.put(phase, threads);

                        for (int thread : rawJSON.get(phase).keySet()) {
                            List<SpeedGraphItemDTO.SpeedItemThreadwise> threadItems = new ArrayList<>();
                            threads.put(String.valueOf(thread),threadItems);

                            //speed items
                            for (SpeedItem item : rawJSON.get(phase).get(thread)) {
                                SpeedGraphItemDTO.SpeedItemThreadwise measurement = new SpeedGraphItemDTO.SpeedItemThreadwise();
                                measurement.setBytesTotal(item.getBytes());
                                measurement.setTimeElapsed(item.getTime());
                                threadItems.add(measurement);
                            }
                        }
                    }

                    dto.setSpeedCurveThreadwise(threadwise);
                }

                //Ping
                List<PingGraphItemDTO> pingGraph = getPingGraph(UUID.fromString(openTestUUID), conn);
                graphs.setPing(pingGraph);

                //Load signal strength from database
                List<SignalGraphItemDTO> radioSignalGraph = getRadioSignalGraph(rs.getLong("test_uid"), UUID.fromString(rs.getObject("open_test_uuid").toString().substring(1)), rs.getTimestamp("client_time").getTime(), conn);
                graphs.setSignal(radioSignalGraph);

                //Load gps coordinates from database
                LocationGraphDTO locGraph = getLocationGraph(rs.getLong("test_uid"),  rs.getTimestamp("client_time").getTime(), conn);
                graphs.setLocation(locGraph.getLocations());

                dto.setSpeedCurve(graphs);


                //add total distance during test - but only if within bounds
                if ((locGraph.getTotalDistance() > 0) &&
                        locGraph.getTotalDistance() <= Double.parseDouble(settings.getString("RMBT_GEO_DISTANCE_DETAIL_LIMIT"))) {
                    dto.setDistance(locGraph.getTotalDistance());
                }


            } else {
                //invalid open_uuid
                setStatus(Status.CLIENT_ERROR_NOT_FOUND);
                dto.setError("invalid open-uuid");
            }
        }
        catch (SQLException ex) {
            setStatus(Status.CLIENT_ERROR_NOT_FOUND);
            dto.setError("invalid open-uuid");

            Logger.getLogger(OpenTestResource.class.getName()).log(Level.SEVERE, null, ex);
        }
        finally
        {
            try
            {
                if (rs != null)
                    rs.close();
                if (ps != null)
                    ps.close();
            }
            catch (final SQLException e)
            {
                Logger.getLogger(OpenTestResource.class.getName()).log(Level.SEVERE, null, e);
            }
        }

        return dto;
    }

    /**
     * Calculate the rough distance in meters between two points
     * taken from http://stackoverflow.com/questions/120283/working-with-latitude-longitude-values-in-java
     * @param lat1
     * @param lng1
     * @param lat2
     * @param lng2
     * @return
     */
    private static double distFrom(double lat1, double lng1, double lat2, double lng2) {
        double earthRadius =  6371000;
        double dLat = Math.toRadians(lat2-lat1);
        double dLng = Math.toRadians(lng2-lng1);
        double sindLat = Math.sin(dLat / 2);
        double sindLng = Math.sin(dLng / 2);
        double a = Math.pow(sindLat, 2) + Math.pow(sindLng, 2)
                * Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2));
        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        double dist = earthRadius * c;

        return dist;
    }

    private LocationGraphDTO getLocationGraph(long testUID, long testTime, java.sql.Connection conn) throws SQLException {
        PreparedStatement psLocation = conn.prepareStatement("SELECT test_id, g.geo_lat latitude, g.geo_long longitude, g.accuracy loc_accuracy, g.bearing bearing, g.speed speed, g.provider provider, altitude, time "
                + " FROM geo_location g "
                + " WHERE g.test_id = ? and accuracy < " + settings.getString("RMBT_GEO_ACCURACY_DETAIL_LIMIT")
                + " ORDER BY time;");
        psLocation.setLong(1, testUID);
        ResultSet rs = psLocation.executeQuery();

        boolean first = true;
        LocationGraphDTO.LocationGraphItem firstItem = null;

        Double lastLat = null;
        Double lastLong = null;
        double totalDistance=0;

        BeanListHandler<LocationGraphDTO.LocationGraphItem> handler = new BeanListHandler<>(LocationGraphDTO.LocationGraphItem.class, new BasicRowProcessor(new GenerousBeanProcessor()));
        List<LocationGraphDTO.LocationGraphItem> allResultList = handler.handle(rs);
        Iterator<LocationGraphDTO.LocationGraphItem> iterator = allResultList.iterator();
        List<LocationGraphDTO.LocationGraphItem> resultList = new ArrayList<>();

        while (iterator.hasNext()) {
            LocationGraphDTO.LocationGraphItem item = iterator.next();
            long timeElapsed = item.getTime().getTime() - testTime;
            item.setTimeElapsed(timeElapsed);

            //there could be measurements taken before a test started
            //in this case, only return the last one
            if (item != null && timeElapsed < 0) {
                lastLat = item.getLatitude();
                lastLong = item.getLongitude();
                item.setTimeElapsed(0);
                firstItem = item;
            }
            //put triplet in the array if it is not the first one
            else {
                //first item > 0 - add item previously stored for later consumption
                if (firstItem != null) {
                    resultList.add(firstItem);
                    firstItem = null;
                }

                //only put the point in the resulting array, if there is a significant
                //distance from the last point
                //therefore (difference in m) > (tolerance last point + tolerance new point)
                if (lastLat != null && lastLong != null) {
                    double diff = OpenTestResource.distFrom(lastLat, lastLong, item.getLatitude(), item.getLongitude());
                    totalDistance += diff;
                }

                resultList.add(item);
                lastLat = item.getLatitude();
                lastLong = item.getLongitude();
            }
        }

        //if no item was with time > 0 - add the last one here
        if (firstItem != null) {
            resultList.add(firstItem);
        }

        LocationGraphDTO lg = new LocationGraphDTO();
        lg.setLocations(resultList);
        lg.setTotalDistance(totalDistance);
        return lg;
    }

    private List<PingGraphItemDTO> getPingGraph(UUID openTestUuid, java.sql.Connection conn) throws SQLException {
        PreparedStatement psPing = conn.prepareStatement("SELECT value_server/1e6 ping_ms, time_ns/1e6 time_elapsed FROM  ping WHERE open_test_uuid = ?");
        psPing.setObject(1, openTestUuid);

        BeanListHandler<PingGraphItemDTO> handler = new BeanListHandler<>(PingGraphItemDTO.class,new BasicRowProcessor(new GenerousBeanProcessor()));
        List<PingGraphItemDTO> pingList = handler.handle(psPing.executeQuery());

        return pingList;
    }


    private static List<SignalGraphItemDTO> getRadioSignalGraph(long testUID, UUID openTestUuid, long testTime, java.sql.Connection conn) throws SQLException {
        final int LOWER_BOUND = -1500;
        final int MAX_TIME = 60000;

        boolean additionalInformation = true;
        PreparedStatement psSignal = conn.prepareStatement("SELECT radio_cell.open_test_uuid, radio_cell.mnc, radio_cell.mcc, radio_cell.location_id, radio_cell.area_code, " +
                "radio_cell.primary_scrambling_code, radio_cell.channel_number, " +
                "nt.name network_type, technology cat_technology, signal_strength, lte_rsrp, lte_rsrq, signal_strength wifi_rssi, time " +
                "FROM radio_cell " +
                "JOIN radio_signal ON radio_signal.cell_uuid = radio_cell.uuid " +
                "JOIN network_type nt ON nt.uid = network_type_id " +
                "WHERE radio_signal.open_test_uuid = ? " +
                "AND radio_cell.active = TRUE " +
                "  ORDER BY radio_signal.time;");
        psSignal.setObject(1, openTestUuid);

        ResultSet rsSignal = psSignal.executeQuery();

        //if there are no results -> try using the old tables that may be available for some measurements
        if (!rsSignal.isBeforeFirst()) {
            psSignal.close();
            additionalInformation = false;

            psSignal = conn.prepareStatement("SELECT test_id, nt.name network_type, nt.group_name cat_technology, signal_strength, lte_rsrp, lte_rsrq, wifi_rssi, time "
                    + "FROM signal "
                    + "JOIN network_type nt "
                    + "ON nt.uid = network_type_id "
                    + "WHERE test_id = ? "
                    + "ORDER BY time;");
            psSignal.setLong(1, testUID);

            rsSignal = psSignal.executeQuery();

        }

        boolean first = true;
        SignalGraphItemDTO item = null;
        List<SignalGraphItemDTO> signalList = new ArrayList<>();
        while (rsSignal.next()) {
            long timeElapsed = rsSignal.getTimestamp("time").getTime() - testTime;
            //there could be measurements taken before a test started
            //in this case, only return the last one
            if (first && timeElapsed > 0 && item != null) {
                signalList.add(item);
                first = false;
            }

            //ignore measurements after a threshold of one minute
            if (timeElapsed > MAX_TIME)
                break;


            Integer signalStrength = rsSignal.getInt("signal_strength");
            int lteRsrp = rsSignal.getInt("lte_rsrp");
            int lteRsrq = rsSignal.getInt("lte_rsrq");
            if (signalStrength == 0) {
                signalStrength = rsSignal.getInt("wifi_rssi");
            }

            if ((signalStrength != 0 && signalStrength > LOWER_BOUND) || lteRsrp > LOWER_BOUND || lteRsrq > LOWER_BOUND) {
                if (additionalInformation) {
                    int channelNumber = rsSignal.getInt("channel_number");
                    item = new SignalGraphItemDTO();
                    item.setTimeElapsed(Math.max(timeElapsed,0));

                    item = new SignalGraphItemDTO(Math.max(timeElapsed, 0), rsSignal.getString("network_type"), signalStrength, lteRsrp, lteRsrq, rsSignal.getString("cat_technology"),
                            rsSignal.getInt("location_id"), rsSignal.getInt("area_code"), rsSignal.getInt("primary_scrambling_code"), channelNumber);
                }
                else {
                    item = new SignalGraphItemDTO(Math.max(timeElapsed, 0), rsSignal.getString("network_type"), signalStrength, lteRsrp, lteRsrq, rsSignal.getString("cat_technology"));
                }
            }


            //put 5-let in the array if it is not the first one
            if (!first || rsSignal.isLast()) {
                if (timeElapsed < 0) {
                    item.setTimeElapsed(1000);
                }
                signalList.add(item);
            }
        }

        rsSignal.close();
        psSignal.close();
        return signalList;
    }

}
