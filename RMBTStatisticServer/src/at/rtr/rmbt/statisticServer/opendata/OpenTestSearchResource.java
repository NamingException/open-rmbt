/*******************************************************************************
 * Copyright 2013-2016 Thomas Schreiber
 * Copyright 2013-2016 Rundfunk und Telekom Regulierungs-GmbH (RTR-GmbH)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/
package at.rtr.rmbt.statisticServer.opendata;


import at.rtr.rmbt.shared.Classification;
import at.rtr.rmbt.shared.cache.CacheHelper;
import at.rtr.rmbt.statisticServer.ServerResource;
import at.rtr.rmbt.statisticServer.opendata.dto.OpenTestDTO;
import at.rtr.rmbt.statisticServer.opendata.dto.OpenTestSearchDTO;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.PropertyNamingStrategy;
import com.fasterxml.jackson.dataformat.csv.CsvGenerator;
import com.fasterxml.jackson.dataformat.csv.CsvMapper;
import com.fasterxml.jackson.dataformat.csv.CsvSchema;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiImplicitParam;
import io.swagger.annotations.ApiImplicitParams;
import io.swagger.annotations.ApiOperation;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.dbutils.BasicRowProcessor;
import org.apache.commons.dbutils.GenerousBeanProcessor;
import org.apache.commons.dbutils.handlers.BeanListHandler;
import org.json.JSONException;
import org.json.JSONObject;
import org.restlet.data.*;
import org.restlet.representation.Representation;
import org.restlet.representation.StringRepresentation;
import org.restlet.resource.Get;
import org.restlet.resource.Post;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

@Api(value="/opentests/search", description = "Open test search")
public class OpenTestSearchResource extends ServerResource
{
    private enum FieldType {STRING, DATE, LONG, DOUBLE, BOOLEAN, UUID, SORTBY, SORTORDER, IGNORE};

    private static final int CACHE_EXP = 3600;
    private static final CSVFormat csvFormat = CSVFormat.RFC4180;
    private static final String CSV_FILENAME = "opentests.csv";

    private final CacheHelper cache = CacheHelper.getInstance();

    public final int MAXROWS = 10000;  //maximum number of rows allowed, currently approx 1.5s response time at maximum
    public final int DEFAULTROWS = 100; //default number of rows (when max_results is not specified)
    public final int MAXQUERYFIELDS = 50; //to prevent database-server overload


      //all fields that should be displayed in a general request (e.g. all tests for one user)
    private final String[] openDataFieldsSummary = {"open_uuid", "open_test_uuid", "time", "lat", "long", "download_kbit", "upload_kbit",
        "ping_ms", "signal_strength", "lte_rsrp",  "platform", "provider_name", "model", "loc_accuracy"};

    //all fields that are numbers (and are formatted as numbers in json)
    private final HashSet<String> openDataNumberFields = new HashSet<>(Arrays.asList(new String[]{"time", "lat", "long", "download_kbit",
        "upload_kbit","ping_ms","signal_strength", "lte_rsrp", "test_duration","num_threads","ndt_download_kbit","ndt_upload_kbit","asn","loc_accuracy"}));

    //all fields for which the user can sort the result
    private final HashSet<String> openDataFieldsSortable = new HashSet<>(Arrays.asList(new String[]{"download_kbit","upload_kbit","time","signal_strength","ping_ms"}));

    //additional fields that the user is allowed to request
    private final HashSet<String> allowedAdditionalFields = new HashSet<>(Arrays.asList(new String[] {"download_classification","upload_classification","ping_classification"}));



    @Get
    @Post
    @GET
    @Path("/opentests/search")
    @ApiOperation(httpMethod = "GET",
            value = "Search for open data tests",
            response = OpenTestSearchDTO.class)
    @ApiImplicitParams({
            @ApiImplicitParam(name = "download_kbit", value = "Download speed in kilobit per second", dataType = "string", example = ">6903", paramType = "query"),
            @ApiImplicitParam(name = "upload_kbit", value = "User's email", dataType = "string", example = "<4670", paramType = "query"),
            @ApiImplicitParam(name = "ping_ms", value = "User ID", dataType = "string", example = "<16", paramType = "query"),
            @ApiImplicitParam(name = "gkz", value = "User ID", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "gkz_sa", value = "User ID", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "cat_technology", value = "User ID", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "client_version", value = "User ID", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "model", value = "User ID", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "network_name", value = "User ID", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "network_type", value = "User ID", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "platform", value = "User ID", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "signal_strength", value = "User ID", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "open_uuid", value = "User ID", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "open_test_uuid", value = "User ID", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "client_uuid", value = "User ID", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "test_uuid", value = "User ID", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "long", value = "User ID", dataType = "number", paramType = "query"),
            @ApiImplicitParam(name = "lat", value = "User ID", dataType = "number", paramType = "query"),
            @ApiImplicitParam(name = "radius", value = "User ID", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "mobile_provider_name", value = "User ID", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "provider_name", value = "User ID", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "sim_mcc_mnc", value = "User ID", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "sim_country", value = "User ID", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "network_country", value = "User ID", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "country_geoip", value = "User ID", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "country_location", value = "User ID", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "user_server_selection", value = "User ID", dataType = "boolean", paramType = "query"),
            @ApiImplicitParam(name = "loc_accuracy", value = "User ID", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "public_ip_as_name", value = "User ID", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "time", value = "User ID", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "sender", value = "User ID", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "additional_info", value = "additional properties to return", example = "download_classification", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "radio_band", value = "User ID", dataType = "long", paramType = "query"),
            @ApiImplicitParam(name = "cell_area_code", value = "User ID", dataType = "long", paramType = "query"),
            @ApiImplicitParam(name = "cell_location_id", value = "User ID", dataType = "long", paramType = "query")
    })
    public Representation request(final Representation entity) throws JSONException {
        addAllowOrigin();

        final JSONObject response = new JSONObject();
        final Form getParameters;
        if (getRequest().getMethod().equals(Method.POST)) {
            // HTTP POST
            getParameters = new Form(entity);
        }
        else {
            // HTTP GET
            getParameters = getRequest().getResourceRef().getQueryAsForm();
        }

        final QueryParser qp = new QueryParser();

        final Set<String> additionalFields;
        final List<String> invalidElements = qp.parseQuery(getParameters);
        OpenTestSearchDTO ret = new OpenTestSearchDTO();


        //calculate offset
        long offset = -1;
        if (getParameters.getNames().contains("cursor")) {
            //is always a valid LONG because it is checked with all other
            //parameters above
            offset = Long.parseLong(getParameters.getFirstValue("cursor"));
        }

        //get maximal results-parameter
        long maxrows = DEFAULTROWS;
        if (getParameters.getNames().contains("max_results")) {
            //is always a valid LONG because it is checked with all other
            //parameters above
            maxrows = Long.parseLong(getParameters.getFirstValue("max_results"));
        }

        //parse additional fields
        if (getParameters.getNames().contains("additional_info") || getParameters.getNames().contains("additional_info[]")) {
            String param = (getParameters.getNames().contains("additional_info")) ? "additional_info" : "additional_info[]";
            for (String field : getParameters.getValuesArray(param)) {
                if (!allowedAdditionalFields.contains(field)) {
                    invalidElements.add(param);
                }
            }
            additionalFields = new HashSet<>(Arrays.asList(getParameters.getValuesArray(param)));
        } else {
            additionalFields = new HashSet<>();
        }

        String format = getParameters.getFirstValue("format", "json").toLowerCase();;

        //if there have been errors => inform the user
        if (invalidElements.size() > 0) {
            setStatus(Status.CLIENT_ERROR_BAD_REQUEST);
            response.put("invalid_fields", invalidElements);
            ret.getInvalidFields().addAll(invalidElements);
        }

        //if there are too many query elements (DoS-Attack?), don't let it
        //get to the database
        else if (qp.getWhereParams().keySet().size() > MAXQUERYFIELDS) {
            setStatus(Status.CLIENT_ERROR_BAD_REQUEST);
            ret.getInvalidFields().add("field limit exceeded");
        }
        else {
            //if valid input, query the db
            ret = getSearchResult(qp, offset, maxrows, additionalFields, format);
        }

        StringRepresentation sr = null;

        //format, depending on output format
        try {
            if (format.equals("json")) {
                ObjectMapper om = new ObjectMapper();
                om.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
                sr = new StringRepresentation(om.writer().writeValueAsString(ret));
            } else if (format.equals("csv")) {
                CsvMapper cm = new CsvMapper();
                cm.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
                cm.enable(CsvGenerator.Feature.STRICT_CHECK_FOR_QUOTING);
                CsvSchema schema = cm.schemaFor(OpenTestDTO.class).withHeader();
                sr = new StringRepresentation(cm.writer(schema).writeValueAsString(ret.getResults()));
            }
        } catch (JsonProcessingException e) {
            e.printStackTrace();
            setStatus(Status.SERVER_ERROR_INTERNAL);
        }

        sr.setCharacterSet(CharacterSet.UTF_8);
        if (format.equals("csv")) {
            //Disposition disposition = new Disposition(Disposition.TYPE_ATTACHMENT);
            //disposition.setFilename(CSV_FILENAME);
            sr.setMediaType(MediaType.TEXT_PLAIN);
            //sr.setDisposition(disposition);
        }
        else {
            sr.setMediaType(MediaType.APPLICATION_JSON);
        }

        return sr;
    }



    /**
     * Gets a JSON-String containing all open-data-values of all rows
     * that matched the given criteria
     * @param qp the queryParse-object
     * @param offset a offset-value for paging (given as "next-cursor" in the response), -1 if none is set
     * @param maxrows maximal count of rows returned
     * @param additionalFields additional fields that should be included in the response
     * @return
     */
    private OpenTestSearchDTO getSearchResult(QueryParser qp, long offset, long maxrows, Set<String> additionalFields, final String format) {
        long startTime = System.currentTimeMillis();
        OpenTestSearchDTO dto = new OpenTestSearchDTO();

        String offsetString = (offset>0)? " AND t.uid<"+offset:""; //if no sorting is used
        String offsetString2 = (offset>0)? " OFFSET "+offset:""; //if sorting is used => may have concurrency issues in the results

        String orderClause = qp.getOrderClause();
        boolean defaultOrder = true;
        if (orderClause == null || orderClause.isEmpty()) {
            orderClause = " ORDER BY t.uid DESC ";
            offsetString2 = "";
        } else {
            defaultOrder = false;
            offsetString = "";
        }

        if (maxrows>MAXROWS)
        	maxrows = MAXROWS;
        if (maxrows <= 0)
            maxrows = DEFAULTROWS;


        //There are many LEFT JOINs in the sql statement that are usual not needed.
        //This has no significant impact on the performance since our DBMS (postgres)
        //is intelligent enough to ignore these during query optimization if they are
        //not needed
        final String sql = "SELECT" +
                " t.uid as cursor, " + //only for pagination
                " ('P' || t.open_uuid) open_uuid," +
                " ('O' || t.open_test_uuid) open_test_uuid," +
                " to_char(t.time AT TIME ZONE 'UTC', 'YYYY-MM-DD HH24:MI:SS') \"time\"," +
                //" nt.group_name cat_technology," +
                //" nt.name network_type," +

                //csv 6:lat
                " (CASE WHEN (t.geo_accuracy < ?) AND (t.geo_provider IS DISTINCT FROM 'manual') AND (t.geo_provider IS DISTINCT FROM 'geocoder') THEN" +
                " t.geo_lat" +
                " WHEN (t.geo_accuracy < ?) THEN" +
                " ROUND(t.geo_lat*1111)/1111" + // approx 100m
                " ELSE null" +
                " END) latitude," +
                // csv 7:long
                " (CASE WHEN (t.geo_accuracy < ?) AND (t.geo_provider IS DISTINCT FROM 'manual') AND (t.geo_provider IS DISTINCT FROM 'geocoder') THEN" +
                " t.geo_long" +
                " WHEN (t.geo_accuracy < ?) THEN" +
                " ROUND(t.geo_long*741)/741 " + //approx 100m
                " ELSE null" +
                " END) longitude," +
	             // accuracy of geo location in m
	             " (CASE WHEN (t.geo_accuracy < ?) AND (t.geo_provider IS DISTINCT FROM 'manual') AND (t.geo_provider IS DISTINCT FROM 'geocoder') " +
	             " THEN t.geo_accuracy " +
	             " WHEN (t.geo_accuracy < 100) AND ((t.geo_provider = 'manual') OR (t.geo_provider = 'geocoder')) THEN 100" + // limit accuracy to 100m
	             " WHEN (t.geo_accuracy < ?) THEN t.geo_accuracy" +
	             " ELSE null END) loc_accuracy, " +
                //" t.geo_provider loc_src," +
                " t.speed_download download_kbit," +
                " t.speed_upload upload_kbit," +
                " (t.ping_median::float / 1000000) ping_ms," +
                " t.signal_strength," +
                " t.lte_rsrp," +
                //" ts.name server_name," +
                //" duration test_duration," +
                //" num_threads," +
                " CONCAT(plattform,' ',network_group_name) as platform, " +
                " COALESCE(adm.fullname, t.model) model," +
                " COALESCE(mprov.shortname, t.network_operator_name, prov.shortname, msim.shortname,msim.name,"
                + "    prov.name, mprov.name, t.public_ip_as_name, network_sim_operator) provider_name " +
                //" client_software_version client_version," +
                //" network_operator network_mcc_mnc," +
                //" network_operator_name network_name," +
                //" network_sim_operator sim_mcc_mnc," +
                //" nat_type \"connection\"," +
                //" public_ip_asn asn," +
                //" client_public_ip_anonymized ip_anonym," +
                //" (ndt.s2cspd*1000)::int ndt_download_kbit," +
                //" (ndt.c2sspd*1000)::int ndt_upload_kbit" +
                " FROM test t" +
                qp.getJoins() +
                " WHERE " +
                " (t.deleted = false)" +
                " AND status = 'FINISHED' " + qp.getWhereClause("AND") + offsetString +
                orderClause + " LIMIT " + maxrows + offsetString2;


        PreparedStatement ps = null;
        ResultSet rs = null;
        try
        {
            ps = conn.prepareStatement(sql);

            //don't show coordinates when not accurate enough
            double accuracy = Double.parseDouble(settings.getString("RMBT_GEO_ACCURACY_DETAIL_LIMIT"));
            ps.setDouble(1, accuracy);
            ps.setDouble(2, accuracy);
            ps.setDouble(3, accuracy);
            ps.setDouble(4, accuracy);
            ps.setDouble(5, accuracy);
            ps.setDouble(6, accuracy);

            //fill in values for WHERE
            //ps = fillInWhereClause(ps, searchValues, 1);
            qp.fillInWhereClause(ps, 7);

            if (!ps.execute())
                return null;
            rs = ps.getResultSet();

            BeanListHandler<OpenTestDTO> handler = new BeanListHandler<>(OpenTestDTO.class,new BasicRowProcessor(new GenerousBeanProcessor()));
            List<OpenTestDTO> results = handler.handle(rs);

            dto.setResults(results);

            //remember last uid for pagination since rs can only be traversed in one direction
            //if there are more results than we send, use pagination
            if (dto.getResults().size() == maxrows) {
                //if it is the standard sort order
                if (defaultOrder) {
                    dto.setNextCursor(results.get(results.size() - 1).getCursor());
                } else {
                    offset = (offset<0) ? 0 : offset;
                    dto.setNextCursor(offset + maxrows);
                }
            } else {
                dto.setNextCursor(null);
            }

            //also put in the result, how long the query took to execute
            long elapsedTime = System.currentTimeMillis() - startTime;
            //jsonResponse.put("duration_ms",elapsedTime);
            dto.setDurationMs(elapsedTime);

            if (additionalFields != null) {
                for (OpenTestDTO result : dto.getResults()) {
                    if (additionalFields.contains("download_classification")) {
                        result.setDownloadClassification(Classification.classify(Classification.THRESHOLD_DOWNLOAD, result.getDownloadKbit(), 4));
                    }
                    if (additionalFields.contains("upload_classification")) {
                        result.setUploadClassification(Classification.classify(Classification.THRESHOLD_UPLOAD, result.getUploadKbit(), 4));
                    }
                    if (additionalFields.contains("ping_classification")) {
                        result.setPingClassification(Classification.classify(Classification.THRESHOLD_PING, Math.round(result.getPingMs() * 1000000), 4));
                    }
                }
            }

        }
        catch (SQLException ex) {
            try {
                setStatus(Status.CLIENT_ERROR_NOT_FOUND);
            } catch (JSONException ex1) {
                Logger.getLogger(OpenTestSearchResource.class.getName()).log(Level.SEVERE, null, ex1);
            }
            Logger.getLogger(OpenTestSearchResource.class.getName()).log(Level.SEVERE, null, ex);
        }
        finally
        {
            try
            {
                if (rs != null)
                    rs.close();
                if (ps != null)
                    ps.close();
            }
            catch (final SQLException e)
            {
                Logger.getLogger(OpenTestSearchResource.class.getName()).log(Level.SEVERE, null, e);
            }
        }
        return dto;
    }

}

